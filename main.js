/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Voice2TextPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/components/AudioRecorder.ts
var AudioRecorder = class {
  constructor() {
    this.mediaRecorder = null;
    this.audioChunks = [];
    this.isRecording = false;
    this.isPaused = false;
    this.stream = null;
  }
  async startRecording() {
    try {
      this.stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      this.mediaRecorder = new MediaRecorder(this.stream);
      this.mediaRecorder.ondataavailable = (event) => {
        this.audioChunks.push(event.data);
      };
      this.mediaRecorder.start();
      this.isRecording = true;
    } catch (error) {
      throw new Error("\u65E0\u6CD5\u8BBF\u95EE\u9EA6\u514B\u98CE");
    }
  }
  pauseRecording() {
    if (this.mediaRecorder && this.isRecording) {
      this.mediaRecorder.pause();
      this.isPaused = true;
    }
  }
  resumeRecording() {
    if (this.mediaRecorder && this.isPaused) {
      this.mediaRecorder.resume();
      this.isPaused = false;
    }
  }
  async stopRecording() {
    return new Promise((resolve) => {
      if (this.mediaRecorder) {
        this.mediaRecorder.onstop = () => {
          const audioBlob = new Blob(this.audioChunks, { type: "audio/wav" });
          this.audioChunks = [];
          resolve(audioBlob);
        };
        this.mediaRecorder.stop();
        this.isRecording = false;
      }
    });
  }
  getStream() {
    return this.stream;
  }
  cleanup() {
    if (this.mediaRecorder) {
      if (this.isRecording) {
        this.mediaRecorder.stop();
      }
      this.mediaRecorder = null;
    }
    if (this.stream) {
      this.stream.getTracks().forEach((track) => track.stop());
      this.stream = null;
    }
    this.audioChunks = [];
    this.isRecording = false;
    this.isPaused = false;
  }
};

// src/components/TranscriptionService.ts
var TranscriptionService = class {
  constructor(apiKey = "") {
    this.apiKey = apiKey;
    this.apiEndpoint = "https://api.openai.com/v1/audio/transcriptions";
  }
  setApiKey(key) {
    this.apiKey = key;
  }
  getApiKey() {
    return this.apiKey;
  }
  async transcribe(audioBlob) {
    if (!this.apiKey) {
      throw new Error("\u8BF7\u5148\u5728\u8BBE\u7F6E\u4E2D\u914D\u7F6E OpenAI API Key");
    }
    const formData = new FormData();
    formData.append("file", audioBlob, "audio.wav");
    formData.append("model", "whisper-1");
    formData.append("language", "zh");
    formData.append("response_format", "json");
    formData.append("temperature", "0");
    try {
      const response = await fetch(this.apiEndpoint, {
        method: "POST",
        headers: {
          "Authorization": `Bearer ${this.apiKey}`
        },
        body: formData
      });
      if (!response.ok) {
        throw new Error("\u8F6C\u5199\u8BF7\u6C42\u5931\u8D25: " + response.status);
      }
      const data = await response.json();
      return data.text;
    } catch (error) {
      throw new Error("\u8BED\u97F3\u8F6C\u5199\u5931\u8D25: " + error.message);
    }
  }
};

// src/components/SettingsTab.ts
var import_obsidian = require("obsidian");
var DEFAULT_SETTINGS = {
  openaiApiKey: "",
  saveAudio: true,
  audioFolder: "recordings"
};
var Voice2TextSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin, settings) {
    super(app, plugin);
    this.plugin = plugin;
    this.settings = settings;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "\u8BED\u97F3\u8F6C\u6587\u5B57\u8BBE\u7F6E" });
    new import_obsidian.Setting(containerEl).setName("OpenAI API Key").setDesc("\u8BF7\u8F93\u5165\u60A8\u7684 OpenAI API Key").addText((text) => text.setPlaceholder("\u8F93\u5165\u60A8\u7684 API Key").setValue(this.settings.openaiApiKey).onChange(async (value) => {
      this.settings.openaiApiKey = value;
      await this.plugin.saveData(this.settings);
      this.plugin.transcriptionService.setApiKey(value);
    }));
    new import_obsidian.Setting(containerEl).setName("\u4FDD\u5B58\u97F3\u9891\u6587\u4EF6").setDesc("\u662F\u5426\u4FDD\u5B58\u5F55\u97F3\u6587\u4EF6\u5230\u6587\u6863\u5E93").addToggle((toggle) => toggle.setValue(this.settings.saveAudio).onChange(async (value) => {
      this.settings.saveAudio = value;
      await this.plugin.saveData(this.settings);
    }));
    new import_obsidian.Setting(containerEl).setName("\u97F3\u9891\u6587\u4EF6\u4FDD\u5B58\u8DEF\u5F84").setDesc("\u8BBE\u7F6E\u5F55\u97F3\u6587\u4EF6\u7684\u4FDD\u5B58\u8DEF\u5F84\uFF0C\u9ED8\u8BA4\u4E3A recordings \u6587\u4EF6\u5939").addText((text) => text.setPlaceholder("\u8F93\u5165\u4FDD\u5B58\u8DEF\u5F84").setValue(this.settings.audioFolder).onChange(async (value) => {
      this.settings.audioFolder = value;
      await this.plugin.saveData(this.settings);
    }));
  }
};

// src/components/RecordingModal.ts
var import_obsidian2 = require("obsidian");
var AudioVisualizer = class {
  constructor(canvas) {
    this.canvas = canvas;
    this.animationId = null;
    this.isPaused = false;
    this.audioContext = new AudioContext();
    this.analyser = this.audioContext.createAnalyser();
    this.analyser.fftSize = 256;
    this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
  }
  connectStream(stream) {
    const source = this.audioContext.createMediaStreamSource(stream);
    source.connect(this.analyser);
    this.startVisualization();
  }
  startVisualization() {
    const draw = () => {
      if (this.isPaused) {
        this.animationId = requestAnimationFrame(draw);
        return;
      }
      this.analyser.getByteFrequencyData(this.dataArray);
      const width = this.canvas.width;
      const height = this.canvas.height;
      const ctx = this.canvas.getContext("2d");
      if (!ctx)
        return;
      ctx.fillStyle = "#1a1a1a";
      ctx.fillRect(0, 0, width, height);
      const barWidth = width / this.dataArray.length;
      let x = 0;
      ctx.fillStyle = "#4CAF50";
      for (let i = 0; i < this.dataArray.length; i++) {
        const barHeight = this.dataArray[i] / 255 * height;
        const gradient = ctx.createLinearGradient(x, height, x, height - barHeight);
        gradient.addColorStop(0, "#4CAF50");
        gradient.addColorStop(1, "#81C784");
        ctx.fillStyle = gradient;
        ctx.fillRect(x, height - barHeight, barWidth, barHeight);
        x += barWidth;
      }
      this.animationId = requestAnimationFrame(draw);
    };
    draw();
  }
  pause() {
    this.isPaused = true;
  }
  resume() {
    this.isPaused = false;
  }
  stop() {
    if (this.animationId !== null) {
      cancelAnimationFrame(this.animationId);
      this.animationId = null;
    }
    this.audioContext.close();
  }
};
var RecordingModal = class extends import_obsidian2.Modal {
  constructor(app, onRecordingClose, onPause, onResume, stream) {
    super(app);
    this.onRecordingClose = onRecordingClose;
    this.onPause = onPause;
    this.onResume = onResume;
    this.stream = stream;
    this.timer = 0;
    this.timerInterval = null;
    this.isPaused = false;
    this.transcriptionText = "";
    this.isTranscribing = false;
    this.transcribingContainer = null;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    const container = contentEl.createDiv("voice2text-modal-container");
    const waveformContainer = container.createDiv("voice2text-waveform-container");
    const canvas = document.createElement("canvas");
    canvas.width = 300;
    canvas.height = 100;
    canvas.className = "voice2text-waveform";
    waveformContainer.appendChild(canvas);
    const timerDisplay = container.createDiv("voice2text-timer");
    timerDisplay.setText("00:00");
    const controlsContainer = container.createDiv("voice2text-controls");
    const cancelButton = controlsContainer.createEl("button", { cls: "voice2text-button" });
    cancelButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>';
    cancelButton.addEventListener("click", () => {
      this.stopRecording(true);
      this.close();
    });
    const pauseButton = controlsContainer.createEl("button", { cls: "voice2text-button" });
    const pauseIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>';
    const playIcon = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>';
    pauseButton.innerHTML = pauseIcon;
    pauseButton.addEventListener("click", () => {
      if (this.isPaused) {
        this.resumeRecording();
        pauseButton.innerHTML = pauseIcon;
      } else {
        this.pauseRecording();
        pauseButton.innerHTML = playIcon;
      }
    });
    const saveButton = controlsContainer.createEl("button", { cls: "voice2text-button" });
    saveButton.innerHTML = '<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>';
    saveButton.addEventListener("click", () => {
      this.stopRecording(false);
      this.close();
    });
    const transcriptionContainer = container.createDiv("voice2text-transcription");
    transcriptionContainer.style.display = "none";
    this.transcribingContainer = container.createDiv("voice2text-transcribing");
    this.transcribingContainer.style.display = "none";
    this.transcribingContainer.innerHTML = '<span class="voice2text-transcribing-text">AI \u8F6C\u5199\u4E2D</span><span class="voice2text-transcribing-dots"><span>.</span><span>.</span><span>.</span></span>';
    this.visualizer = new AudioVisualizer(canvas);
    this.visualizer.connectStream(this.stream);
    this.startTimer();
  }
  startTimer() {
    this.timerInterval = window.setInterval(() => {
      if (!this.isPaused) {
        this.timer++;
        const minutes = Math.floor(this.timer / 60);
        const seconds = this.timer % 60;
        const timerDisplay = this.contentEl.querySelector(".voice2text-timer");
        if (timerDisplay) {
          timerDisplay.setText(`${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`);
        }
      }
    }, 1e3);
  }
  pauseRecording() {
    this.isPaused = true;
    this.onPause();
    this.visualizer.pause();
  }
  resumeRecording() {
    this.isPaused = false;
    this.onResume();
    this.visualizer.resume();
  }
  stopRecording(cancelled) {
    if (this.timerInterval) {
      clearInterval(this.timerInterval);
    }
    this.visualizer.stop();
    this.onRecordingClose(cancelled);
  }
  setTranscriptionText(text) {
    this.transcriptionText = text;
    const transcriptionContainer = this.contentEl.querySelector(".voice2text-transcription");
    if (transcriptionContainer) {
      transcriptionContainer.style.display = "block";
      this.typeText(transcriptionContainer, text);
    }
  }
  showTranscribing() {
    if (this.transcribingContainer) {
      this.transcribingContainer.style.display = "flex";
    }
  }
  hideTranscribing() {
    if (this.transcribingContainer) {
      this.transcribingContainer.style.display = "none";
    }
  }
  async typeText(element, text) {
    element.empty();
    const textContainer = element.createDiv("voice2text-typing-text");
    for (let i = 0; i < text.length; i++) {
      const span = document.createElement("span");
      span.textContent = text[i];
      textContainer.appendChild(span);
      await new Promise((resolve) => setTimeout(resolve, 50));
    }
  }
  onClose() {
    if (this.timerInterval) {
      clearInterval(this.timerInterval);
    }
    this.visualizer.stop();
    this.onRecordingClose(true);
  }
};

// main.ts
var Voice2TextPlugin = class extends import_obsidian3.Plugin {
  constructor() {
    super(...arguments);
    this.recordingModal = null;
    this.mediaStream = null;
    this.isRecording = false;
  }
  async onload() {
    await this.loadSettings();
    this.audioRecorder = new AudioRecorder();
    this.transcriptionService = new TranscriptionService(this.settings.openaiApiKey);
    this.addSettingTab(new Voice2TextSettingTab(this.app, this, this.settings));
    this.statusBarItem = this.addStatusBarItem();
    this.statusBarItem.addClass("mod-clickable");
    this.statusBarItem.setAttribute("aria-label", "\u5F00\u59CB\u5F55\u97F3");
    this.statusBarItem.setAttribute("title", "\u70B9\u51FB\u5F00\u59CB\u5F55\u97F3");
    this.statusBarItem.innerHTML = "\u{1F399}";
    this.statusBarItem.addEventListener("click", () => {
      if (!this.isRecording) {
        this.startRecording();
      } else {
        this.stopRecording();
      }
    });
    this.addRibbonIcon("microphone", "\u8BED\u97F3\u5F55\u5236", (evt) => {
      if (!this.isRecording) {
        this.startRecording();
      } else {
        this.stopRecording();
      }
    });
    this.addCommand({
      id: "start-voice-recording",
      name: "\u5F00\u59CB\u8BED\u97F3\u5F55\u5236",
      editorCallback: (editor) => {
        this.startRecording();
      }
    });
    this.addCommand({
      id: "stop-voice-recording",
      name: "\u505C\u6B62\u8BED\u97F3\u5F55\u5236",
      editorCallback: (editor) => {
        this.stopRecording();
      }
    });
  }
  async startRecording() {
    try {
      await this.audioRecorder.startRecording();
      const stream = this.audioRecorder.getStream();
      if (!stream) {
        throw new Error("\u65E0\u6CD5\u83B7\u53D6\u97F3\u9891\u6D41");
      }
      this.isRecording = true;
      this.statusBarItem.innerHTML = "\u23F9";
      this.statusBarItem.setAttribute("aria-label", "\u505C\u6B62\u5F55\u97F3");
      this.statusBarItem.setAttribute("title", "\u70B9\u51FB\u505C\u6B62\u5F55\u97F3");
      this.recordingModal = new RecordingModal(
        this.app,
        async (cancelled) => {
          if (!cancelled) {
            await this.stopRecording();
          } else {
            this.audioRecorder.cleanup();
          }
          this.recordingModal = null;
        },
        () => this.audioRecorder.pauseRecording(),
        () => this.audioRecorder.resumeRecording(),
        stream
      );
      this.recordingModal.open();
    } catch (error) {
      new import_obsidian3.Notice("\u5F55\u97F3\u5931\u8D25: " + error.message);
    }
  }
  async stopRecording() {
    try {
      const audioBlob = await this.audioRecorder.stopRecording();
      const view = this.app.workspace.getActiveViewOfType(import_obsidian3.MarkdownView);
      if (!view) {
        new import_obsidian3.Notice("\u8BF7\u5148\u6253\u5F00\u4E00\u4E2A\u7B14\u8BB0\u6587\u4EF6");
        return;
      }
      const audioFilePath = await this.saveAudioFile(audioBlob);
      const editor = view.editor;
      const cursor = editor.getCursor();
      editor.replaceRange(`![[${audioFilePath}]]

`, cursor);
      new import_obsidian3.Notice("\u6B63\u5728\u8F6C\u5199...");
      const text = await this.transcriptionService.transcribe(audioBlob);
      if (this.recordingModal) {
        this.recordingModal.setTranscriptionText(text);
      }
      const newCursor = editor.getCursor();
      editor.replaceRange(`${text}

`, newCursor);
    } catch (error) {
      new import_obsidian3.Notice("\u8F6C\u5199\u5931\u8D25: " + error.message);
    } finally {
      this.isRecording = false;
      this.statusBarItem.innerHTML = "\u{1F399}";
      this.statusBarItem.setAttribute("aria-label", "\u5F00\u59CB\u5F55\u97F3");
      this.statusBarItem.setAttribute("title", "\u70B9\u51FB\u5F00\u59CB\u5F55\u97F3");
      if (this.mediaStream) {
        this.mediaStream.getTracks().forEach((track) => track.stop());
        this.mediaStream = null;
      }
    }
  }
  async saveAudioFile(audioBlob) {
    if (!this.settings.saveAudio) {
      return "";
    }
    const timestamp = (/* @__PURE__ */ new Date()).toISOString().replace(/[:.]/g, "-");
    const fileName = `${this.settings.audioFolder}/\u5F55\u97F3_${timestamp}.wav`;
    const folder = this.app.vault.getAbstractFileByPath(this.settings.audioFolder);
    if (!folder) {
      await this.app.vault.createFolder(this.settings.audioFolder);
    }
    const file = new File([audioBlob], fileName, { type: "audio/wav" });
    await this.app.vault.createBinary(fileName, await file.arrayBuffer());
    return fileName;
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  onunload() {
    this.audioRecorder.cleanup();
    if (this.recordingModal) {
      this.recordingModal.close();
    }
    if (this.mediaStream) {
      this.mediaStream.getTracks().forEach((track) => track.stop());
    }
  }
};
