/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => Voice2TextPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/components/AudioRecorder.ts
var AudioRecorder = class {
  constructor() {
    this.mediaRecorder = null;
    this.audioChunks = [];
    this.isRecording = false;
    this.isPaused = false;
  }
  async startRecording() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      this.mediaRecorder = new MediaRecorder(stream);
      this.mediaRecorder.ondataavailable = (event) => {
        this.audioChunks.push(event.data);
      };
      this.mediaRecorder.start();
      this.isRecording = true;
    } catch (error) {
      throw new Error("\u65E0\u6CD5\u8BBF\u95EE\u9EA6\u514B\u98CE");
    }
  }
  pauseRecording() {
    if (this.mediaRecorder && this.isRecording) {
      this.mediaRecorder.pause();
      this.isPaused = true;
    }
  }
  resumeRecording() {
    if (this.mediaRecorder && this.isPaused) {
      this.mediaRecorder.resume();
      this.isPaused = false;
    }
  }
  async stopRecording() {
    return new Promise((resolve) => {
      if (this.mediaRecorder) {
        this.mediaRecorder.onstop = () => {
          const audioBlob = new Blob(this.audioChunks, { type: "audio/wav" });
          this.audioChunks = [];
          resolve(audioBlob);
        };
        this.mediaRecorder.stop();
        this.isRecording = false;
      }
    });
  }
  cleanup() {
    if (this.mediaRecorder) {
      this.mediaRecorder.stream.getTracks().forEach((track) => track.stop());
    }
  }
};

// src/components/TranscriptionService.ts
var TranscriptionService = class {
  constructor(apiKey = "") {
    this.apiKey = apiKey;
    this.apiEndpoint = "https://api.openai.com/v1/audio/transcriptions";
  }
  async transcribe(audioBlob) {
    const formData = new FormData();
    formData.append("audio", audioBlob);
    formData.append("api_key", this.apiKey);
    try {
      const response = await fetch(this.apiEndpoint, {
        method: "POST",
        body: formData
      });
      if (!response.ok) {
        throw new Error("\u8F6C\u5199\u8BF7\u6C42\u5931\u8D25");
      }
      const data = await response.json();
      return data.text;
    } catch (error) {
      throw new Error("\u8BED\u97F3\u8F6C\u5199\u5931\u8D25: " + error.message);
    }
  }
};

// main.ts
var Voice2TextPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.isRecording = false;
  }
  async onload() {
    this.audioRecorder = new AudioRecorder();
    this.transcriptionService = new TranscriptionService();
    this.addRibbonIcon("microphone", "\u8BED\u97F3\u5F55\u5236", (evt) => {
      if (!this.isRecording) {
        this.startRecording();
      } else {
        this.stopRecording();
      }
    });
    this.addCommand({
      id: "start-voice-recording",
      name: "\u5F00\u59CB\u8BED\u97F3\u5F55\u5236",
      editorCallback: (editor) => {
        this.startRecording();
      }
    });
    this.addCommand({
      id: "stop-voice-recording",
      name: "\u505C\u6B62\u8BED\u97F3\u5F55\u5236",
      editorCallback: (editor) => {
        this.stopRecording();
      }
    });
  }
  async startRecording() {
    try {
      await this.audioRecorder.startRecording();
      this.isRecording = true;
      new import_obsidian.Notice("\u5F00\u59CB\u5F55\u97F3...");
    } catch (error) {
      new import_obsidian.Notice("\u5F55\u97F3\u5931\u8D25: " + error.message);
    }
  }
  async stopRecording() {
    if (!this.isRecording)
      return;
    try {
      new import_obsidian.Notice("\u6B63\u5728\u5904\u7406\u5F55\u97F3...");
      const audioBlob = await this.audioRecorder.stopRecording();
      this.isRecording = false;
      const text = await this.transcriptionService.transcribe(audioBlob);
      const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
      if (activeView) {
        const editor = activeView.editor;
        const cursor = editor.getCursor();
        editor.replaceRange(text, cursor);
        new import_obsidian.Notice("\u8BED\u97F3\u5DF2\u8F6C\u6362\u4E3A\u6587\u672C");
      } else {
        new import_obsidian.Notice("\u65E0\u6CD5\u627E\u5230\u6D3B\u52A8\u7684\u7F16\u8F91\u5668\u89C6\u56FE");
      }
    } catch (error) {
      new import_obsidian.Notice("\u5904\u7406\u5F55\u97F3\u5931\u8D25: " + error.message);
    }
  }
  onunload() {
    this.audioRecorder.cleanup();
  }
};
